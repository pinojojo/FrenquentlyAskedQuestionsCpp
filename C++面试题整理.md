[1](https://www.naukri.com/learning/articles/cpp-interview-questions-and-answers/)

[2 知乎](https://www.zhihu.com/question/451327108)



1. Q:C++ 和 C 的主要区别 ？A: 总结如下
   | C++                                      | C                      |
   | ---------------------------------------- | ---------------------- |
   | C++ 是面向对象的                         | C 是面向过程的         |
   | C++ 是 C 的超集                          | C 是 C++ 的子集        |
   | C++ 有 63 个关键字                       | C 有 32 个关键字       |
   | C++ 支持函数重载                         | C 不支持函数重载       |
   | C++ 支持用户自定义类型                   | C 不支持用户自定义类型 |
   | C++ 支持访问修饰符以及由此带来的数据隐藏 | C  不支持访问修饰符    |
   | C++ 支持异常处理                         | C 不支持异常处理       |
   | C++ 支持虚函数                           | C 不支持虚函数         |
   | C++ 支持模板                             | C 不支持模板           |
   | C++ 支持命名空间                         | C 不支持命名空间       |
   | C++ 支持引用                             | C 不支持引用           |

2. Q:shared_ptr 的实现原理 ？A: shared_ptr 是一个智能指针，它的实现原理是引用计数。shared_ptr 会记录当前指针指向的对象有多少个智能指针指向它，当引用计数为 0 时，会自动释放对象所占用的内存。
3. Q:shared_ptr的引用计数是如何实现的？A: shared_ptr 的引用计数是通过一个控制块来实现的，控制块中包含了引用计数和指向对象的指针。shared_ptr 会在构造函数中创建一个控制块，然后将控制块的指针赋值给指针成员变量。当 shared_ptr 被复制时，会将控制块的引用计数加 1，当 shared_ptr 被销毁时，会将控制块的引用计数减 1，当引用计数为 0 时，会自动释放对象所占用的内存。
4. Q:拷贝构造函数是否必须要以引用的方式传递参数？A: 不是必须的，但是如果不以引用的方式传递参数，那么在拷贝构造函数中，会调用拷贝构造函数，这样就会造成无限递归，从而导致栈溢出。而且从 C++11 开始，编译器会对拷贝构造函数进行优化，如果传递的参数是一个右值，那么编译器会直接将这个右值的内容拷贝到新的对象中，而不会调用拷贝构造函数。
5. Q:函数传递参数是指针好还是引用好？ A: 传递指针的好处是可以修改指针指向的对象，传递引用的好处是不会产生临时对象，而且可以避免空指针的问题。但是引用不能被重新 set，而指针可以。大部分情况下 2 种方式都是没有太大区别，优先使用引用。但是如果需要修改指针指向的对象或者允许输入为 nullptr，那么就使用指针。
6. Q:C++怎么处理类型转换的？A:作为一种强类型的语言，C++对其类型的要求很严格。总有一些情况下，你需要将一种类型转换成另一种类型，这就是所谓的铸造。有时，这种转换是隐式进行的。比如说 int 类型的变量可以隐式地转换成 double 类型的变量。有时，这种转换是[显式](https://codeburst.io/understanding-c-casts-ef1f36e54240)进行的。
7. Q: C++ 隐性类型转换有哪些?
8. Q: C++ 显性类型转换有哪些？A: C++ 有 4 种显性类型转换：
      - static_cast
      - dynamic_cast
      - const_cast
      - reinterpret_cast  